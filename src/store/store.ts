import { create } from 'zustand';
import { persist } from 'zustand/middleware';

/**
 * User interface - Represents the user in the application
 */
interface User {
  nickname: string;                                // User's nickname
  tags: string[];                                  // User's tags
}

/**
 * UserProfile interface - Represents additional user information
 */
interface UserProfile {
  weight?: string;                                 // User's weight
  height?: string;                                 // User's height
  personality?: string[];                          // User's personality traits
  interests?: string[];                            // User's interests
  hobbies?: string[];                              // User's hobbies
  goals?: string[];                                // User's personal goals
  notes?: string;                                  // Additional notes
  userContextHistory?: string;                     // 累积式用户上下文历史
  preferredModel?: 'deepseek-r1' | 'gpt-4o';       // 用户偏好的AI模型
  
  // 工作偏好
  workStyle?: string[];                            // Work style preferences
  productivityPeaks?: string[];                    // Times of day when productivity peaks
  
  // 学习偏好
  learningPreferences?: string[];                  // Learning style preferences
  challengeAreas?: string[];                       // Areas where user faces challenges
  
  // 优先级偏好
  priorityFocus?: {
    efficiency: number;                            // Importance of efficiency (1-10)
    quality: number;                               // Importance of quality (1-10)
    creativity: number;                            // Importance of creativity (1-10)
  };
}

/**
 * Task interface - Represents a task in the application
 * Based on the Task model from models.js
 */
interface Task {
  id: string;                                      // Unique identifier for the task
  title: string;                                   // Task title
  description?: string;                            // Optional task description
  dueDate?: string;                                // Optional due date (ISO string format)
  status: 'pending' | 'completed' | 'cancelled';   // Task status
  priority: 'low' | 'medium' | 'high';             // Task priority level
  important: boolean;                              // Whether the task is marked as important
  goalId?: string;                                 // Optional reference to a goal
  taskListId: string;                              // Reference to the list this task belongs to
  feedback?: {text: string; timestamp: string}[];  // Optional array of feedback entries with timestamps
  subtasks?: Subtask[];                            // Optional array of subtasks
  completedAt?: string;                            // Optional completion date (ISO string format)
  
  // Task Graph extension properties
  embeddings?: number[];                           // Semantic embeddings vector for the task (for similarity search)
  relatedTaskIds?: string[];                       // IDs of semantically related tasks
  type?: 'learning' | 'work' | 'health' | 'other'; // Task type categorization
  userPreferences?: TaskUserPreferences;           // User preferences specific to this task
}

/**
 * TaskUserPreferences interface - Represents user preferences specific to a task
 */
interface TaskUserPreferences {
  preferredTimeOfDay?: 'morning' | 'afternoon' | 'evening' | 'night'; // When the user prefers to work on this task
  preferredEnvironment?: string[];                 // Where the user prefers to work on this task
  preferredDuration?: number;                      // How long the user prefers to work on this task (minutes)
  preferredApproach?: string;                      // How the user prefers to approach this task
  difficultyRating?: number;                       // How difficult the user finds this task (1-5)
}

/**
 * TaskEdge interface - Represents a relationship between two tasks
 */
interface TaskEdge {
  fromTaskId: string;                              // Source task ID
  toTaskId: string;                                // Target task ID
  type: 'subtask' | 'related' | 'prerequisite' | 'similar' | 'feedback'; // Relationship type
  weight?: number;                                 // Relationship strength (0-1)
  metadata?: Record<string, any>;                  // Additional metadata about the relationship
}

/**
 * TaskProposal interface - Represents a task proposal generated by the AI
 */
interface TaskProposal {
  id?: string;                                     // Unique identifier (optional until saved)
  summary: string;                                 // Task summary
  steps: string[];                                 // Concrete steps to complete the task
  estimatedTime: string;                           // Estimated time to complete
  risks: string[];                                 // Potential obstacles or challenges
  historyReferences: string[];                     // Related historical tasks
  userAdaptation: string;                          // How this proposal is adapted to the user
}

/**
 * Subtask interface - Represents a subtask of a task
 */
interface Subtask {
  id: string;                                      // Unique identifier for the subtask
  title: string;                                   // Subtask title
  completed: boolean;                              // Whether the subtask is completed
}

/**
 * KeyResult interface - Represents a key result/milestone for a goal
 */
interface KeyResult {
  id: string;                                      // Unique identifier for the key result
  goalId: string;                                  // Parent goal ID
  title: string;                                   // Key result title
  status: 'pending' | 'completed';                 // Status of the key result
}

/**
 * Goal interface - Represents a goal in the application
 * Based on the Goal model from models.js
 */
interface Goal {
  id: string;                                      // Unique identifier for the goal
  title: string;                                   // Goal title
  description?: string;                            // Optional goal description
  dueDate?: string;                                // Optional due date (ISO string format)
  progress: number;                                // Progress as a percentage (0-100)
  status: 'active' | 'completed' | 'cancelled';    // Goal status
  taskIds: string[];                               // Array of associated task IDs
  order?: number;                                  // Display order for the goal (lower numbers appear first)
}

/**
 * TaskList interface - Represents a list that can contain tasks
 */
interface TaskList {
  id: string;                                      // Unique identifier for the list
  name: string;                                    // List name
  description?: string;                            // Optional list description
}

/**
 * AppState interface - Defines the global state and actions for the application
 */
interface AppState {
  // State
  user: User;                                      // User information
  userProfile: UserProfile;                        // User profile information
  tasks: Task[];                                   // Array of all tasks
  goals: Goal[];                                   // Array of all goals
  keyResults: KeyResult[];                         // Array of all key results
  taskLists: TaskList[];                           // Array of all task lists
  selectedList: string;                            // Currently selected list ID
  
  // Task Graph extension
  taskEdges: TaskEdge[];                           // Relationships between tasks
  
  // User actions
  updateUser: (user: Partial<User>) => void;       // Update user information
  updateUserProfile: (profile: Partial<UserProfile>) => void; // Update user profile information
  
  // Task actions
  addTask: (task: Omit<Task, 'id'>) => void;       // Add a new task (ID is generated automatically)
  updateTask: (id: string, task: Partial<Task>) => void; // Update an existing task
  deleteTask: (id: string) => void;                // Delete a task
  toggleTaskComplete: (id: string) => void;        // Toggle a task between completed and pending
  toggleTaskImportant: (id: string) => void;       // Toggle a task's important status
  addTaskFeedback: (id: string, feedback: string) => void; // Add feedback to a task
  
  // Goal actions
  addGoal: (goal: Omit<Goal, 'id'>) => void;       // Add a new goal (ID is generated automatically)
  updateGoal: (id: string, goal: Partial<Goal>) => void; // Update an existing goal
  deleteGoal: (id: string) => void;                // Delete a goal
  reorderGoals: (goalIds: string[]) => void;       // Reorder goals based on array of IDs
  
  // KeyResult actions
  addKeyResult: (keyResult: Omit<KeyResult, 'id'>) => void; // Add a new key result
  updateKeyResult: (id: string, keyResult: Partial<KeyResult>) => void; // Update a key result
  deleteKeyResult: (id: string) => void;           // Delete a key result  
  toggleKeyResultComplete: (id: string) => void;   // Toggle a key result between completed and pending
  updateGoalProgress: (goalId: string) => void;    // Calculate and update a goal's progress based on key results
  
  // TaskList actions
  addTaskList: (taskList: Omit<TaskList, 'id'>) => void; // Add a new task list
  updateTaskList: (id: string, taskList: Partial<TaskList>) => void; // Update a task list
  deleteTaskList: (id: string) => void;            // Delete a task list
  
  // UI state
  setSelectedList: (listId: string) => void;       // Change the currently selected list
  
  // Task Graph actions
  addTaskEdge: (edge: TaskEdge) => void;           // Add a relationship between tasks
  removeTaskEdge: (fromId: string, toId: string) => void; // Remove a relationship between tasks
  findRelatedTasks: (taskId: string) => Task[];    // Find tasks related to a given task
  findSimilarTasks: (taskEmbedding: number[], threshold?: number) => Task[]; // Find tasks similar to embedding
  updateTaskEmbeddings: (taskId: string, embeddings: number[]) => void; // Update task embeddings
  generateTaskProposal: (input: string) => TaskProposal; // Generate a task proposal
  
  // User Context History
  addToUserContextHistory: (context: string) => void;      // 添加新的上下文信息到历史记录
  getUserRelevantContext: (query: string, maxLength?: number) => string;  // 根据查询获取相关上下文
}

/**
 * Main application store using Zustand
 * Includes persistence to localStorage via the persist middleware
 */
export const useAppStore = create<AppState>()(
  persist(
    (set, get) => ({
      // Initial state
      user: {
        nickname: 'Noah',
        tags: ['Builder', '努力减重中']
      },
      userProfile: {
        weight: '70kg',
        height: '175cm',
        personality: ['Focused', 'Creative', 'Analytical'],
        interests: ['AI', 'Programming', 'Reading'],
        hobbies: ['Running', 'Photography', 'Cooking'],
        goals: ['Learn a new language', 'Run a marathon'],
        notes: '',
        userContextHistory: '',
        preferredModel: 'gpt-4o',
        // 工作偏好
        workStyle: [],
        productivityPeaks: [],
        // 学习偏好
        learningPreferences: [],
        challengeAreas: [],
        // 优先级偏好
        priorityFocus: {
          efficiency: 5,
          quality: 5,
          creativity: 5
        }
      },
      tasks: [],
      goals: [],
      keyResults: [],
      taskLists: [
        { id: 'goals', name: 'Goals', description: 'Goals tracking' },
        { id: 'today', name: 'My Day', description: 'Tasks due today' },
        { id: 'important', name: 'Important', description: 'Important tasks' },
        { id: 'all', name: 'Tasks', description: 'All tasks' },
      ],
      selectedList: 'today',
      
      // Task Graph extension
      taskEdges: [],
      
      // User actions
      updateUser: (userData) => {
        set((state) => {
          const updatedUser = { ...state.user, ...userData };
          
          // 将更新的用户信息添加到上下文历史
          const contextUpdate = `[用户更新] 昵称: ${updatedUser.nickname}, 标签: ${updatedUser.tags.join(', ')}`;
          get().addToUserContextHistory(contextUpdate);
          
          return { user: updatedUser };
        });
      },
      
      updateUserProfile: (profileData) => {
        set((state) => {
          const updatedProfile = { ...state.userProfile, ...profileData };
          
          // 将更新的profile信息添加到上下文历史
          let contextUpdate = '[个人资料更新] ';
          if (profileData.weight) contextUpdate += `体重: ${profileData.weight}, `;
          if (profileData.height) contextUpdate += `身高: ${profileData.height}, `;
          if (profileData.personality) contextUpdate += `性格特点: ${profileData.personality.join(', ')}, `;
          if (profileData.interests) contextUpdate += `兴趣: ${profileData.interests.join(', ')}, `;
          if (profileData.hobbies) contextUpdate += `爱好: ${profileData.hobbies.join(', ')}, `;
          if (profileData.goals) contextUpdate += `目标: ${profileData.goals.join(', ')}, `;
          if (profileData.notes) contextUpdate += `备注: ${profileData.notes}`;
          
          get().addToUserContextHistory(contextUpdate);
          
          return { userProfile: updatedProfile };
        });
      },
      
      // 用户上下文历史相关方法
      addToUserContextHistory: (context: string) => {
        set((state) => {
          const timestamp = new Date().toISOString();
          const formattedContext = `[${timestamp}] ${context}\n`;
          
          // 获取现有历史记录，如果不存在则创建新的
          const currentHistory = state.userProfile.userContextHistory || '';
          
          // 添加新的上下文到历史记录
          const updatedProfile = { 
            ...state.userProfile, 
            userContextHistory: currentHistory + formattedContext
          };
          
          console.log('添加到用户上下文历史:', formattedContext);
          
          return { userProfile: updatedProfile };
        });
      },
      
      // 获取与查询相关的上下文
      getUserRelevantContext: (query: string, maxLength = 2000) => {
        const state = get();
        const history = state.userProfile.userContextHistory || '';
        
        // 最简单的实现：如果没有太多历史记录，直接返回所有
        if (history.length <= maxLength) {
          return history;
        }
        
        // TODO: 未来可以实现更复杂的上下文检索逻辑，使用embedding相似度
        // 目前简单的实现：假设最近的条目更重要，返回最近的内容
        const entries = history.split('\n').filter(entry => entry.trim().length > 0);
        let relevantContext = '';
        
        // 从最新到最旧添加条目，直到达到最大长度
        for (let i = entries.length - 1; i >= 0; i--) {
          if ((relevantContext + entries[i] + '\n').length > maxLength) {
            break;
          }
          relevantContext = entries[i] + '\n' + relevantContext;
        }
        
        return relevantContext;
      },
      
      // Task actions
      addTask: (task) => {
        set((state) => {
          const id = generateId();
          const newTask = { id, ...task } as Task;
          
          // 将新任务添加到上下文历史
          const contextUpdate = `[新任务] ID: ${id}, 标题: ${task.title}, 优先级: ${task.priority}, 类型: ${task.type || '未指定'}`;
          get().addToUserContextHistory(contextUpdate);
          
          return { tasks: [...state.tasks, newTask] };
        });
      },
      
      updateTask: (id: string, taskUpdate: Partial<Task>) => {
        set((state) => {
          const tasks = state.tasks.map((t) => {
            if (t.id === id) {
              const updatedTask = { ...t, ...taskUpdate };
              
              // 将任务更新添加到上下文历史
              let contextUpdate = `[任务更新] ID: ${id}`;
              if (taskUpdate.title) contextUpdate += `, 标题: ${taskUpdate.title}`;
              if (taskUpdate.status) contextUpdate += `, 状态: ${taskUpdate.status}`;
              if (taskUpdate.priority) contextUpdate += `, 优先级: ${taskUpdate.priority}`;
              if (taskUpdate.description) contextUpdate += `, 描述已更新`;
              if (taskUpdate.subtasks) contextUpdate += `, 子任务已更新`;
              
              get().addToUserContextHistory(contextUpdate);
              
              return updatedTask;
            }
            return t;
          });
          
          return { tasks };
        });
      },
      
      deleteTask: (id) => {
        set((state) => ({ 
          tasks: state.tasks.filter(task => task.id !== id) 
        }));
      },
      
      toggleTaskComplete: (id) => {
        set((state) => ({ 
          tasks: state.tasks.map(task => 
            task.id === id 
              ? { 
                  ...task, 
                  status: task.status === 'completed' ? 'pending' : 'completed',
                  completedAt: task.status === 'completed' ? undefined : new Date().toISOString()
                } 
              : task
          ) 
        }));
      },
      
      toggleTaskImportant: (id) => {
        set((state) => ({ 
          tasks: state.tasks.map(task => 
            task.id === id 
              ? { ...task, important: !task.important } 
              : task
          ) 
        }));
      },
      
      addTaskFeedback: (id, feedback) => {
        set((state) => {
          const tasks = state.tasks.map((t) => {
            if (t.id === id) {
              const feedbackItem = {
                text: feedback,
                timestamp: new Date().toISOString()
              };
              
              // 将反馈添加到上下文历史
              const contextUpdate = `[任务反馈] 任务ID: ${id}, 反馈: ${feedback}`;
              get().addToUserContextHistory(contextUpdate);
              
              console.log('[Store] 添加任务反馈:', { taskId: id, feedback: feedbackItem, contextUpdate });
              
              return {
                ...t,
                feedback: t.feedback ? [...t.feedback, feedbackItem] : [feedbackItem]
              };
            }
            return t;
          });
          
          return { tasks };
        });
      },
      
      // Goal actions
      addGoal: (goal) => {
        set((state) => ({ 
          goals: [...state.goals, { ...goal, id: `goal-${Date.now()}`, order: state.goals.length }] 
        }));
      },
      
      updateGoal: (id, updatedGoal) => {
        set((state) => ({ 
          goals: state.goals.map(goal => 
            goal.id === id ? { ...goal, ...updatedGoal } : goal
          ) 
        }));
      },
      
      deleteGoal: (id) => {
        set((state) => {
          // Also delete all key results associated with the goal
          const keyResultsToKeep = state.keyResults.filter(kr => kr.goalId !== id);
          return { 
            goals: state.goals.filter(goal => goal.id !== id),
            keyResults: keyResultsToKeep
          };
        });
      },
      
      reorderGoals: (goalIds) => {
        set((state) => {
          // Create a new array of goals with updated order properties
          const updatedGoals = state.goals.map(goal => {
            const newOrder = goalIds.indexOf(goal.id);
            return {
              ...goal,
              order: newOrder !== -1 ? newOrder : goal.order || 999 // If not in the array, keep current order or put at end
            };
          });
          
          // Sort goals by their order
          return {
            goals: updatedGoals.sort((a, b) => (a.order || 0) - (b.order || 0))
          };
        });
      },
      
      // KeyResult actions
      addKeyResult: (keyResult) => {
        const id = `kr-${Date.now()}`;
        set((state) => ({ 
          keyResults: [...state.keyResults, { ...keyResult, id }] 
        }));
        // Update the goal progress
        get().updateGoalProgress(keyResult.goalId);
      },
      
      updateKeyResult: (id, updatedKeyResult) => {
        let goalId: string | null = null;
        set((state) => {
          const updatedKeyResults = state.keyResults.map(kr => {
            if (kr.id === id) {
              goalId = kr.goalId;
              return { ...kr, ...updatedKeyResult };
            }
            return kr;
          });
          return { keyResults: updatedKeyResults };
        });
        // Update the goal progress if needed
        if (goalId) get().updateGoalProgress(goalId);
      },
      
      deleteKeyResult: (id) => {
        try {
          console.log("Store: Deleting key result with id:", id);
          let goalId: string | null = null;
          
          set((state) => {
            console.log("Current key results:", state.keyResults);
            const keyResult = state.keyResults.find(kr => kr.id === id);
            
            if (keyResult) {
              console.log("Found key result to delete:", keyResult);
              goalId = keyResult.goalId;
            } else {
              console.warn("Key result not found with id:", id);
            }
            
            const filteredKeyResults = state.keyResults.filter(kr => kr.id !== id);
            console.log("Filtered key results:", filteredKeyResults);
            
            return { keyResults: filteredKeyResults };
          });
          
          // Update the goal progress if needed
          if (goalId) {
            console.log("Updating goal progress for goal:", goalId);
            get().updateGoalProgress(goalId);
          }
        } catch (error) {
          console.error("Error in deleteKeyResult:", error);
        }
      },
      
      toggleKeyResultComplete: (id) => {
        let goalId: string | null = null;
        set((state) => {
          const updatedKeyResults = state.keyResults.map(kr => {
            if (kr.id === id) {
              goalId = kr.goalId;
              return { 
                ...kr, 
                status: kr.status === 'completed' ? 'pending' as const : 'completed' as const 
              };
            }
            return kr;
          });
          return { keyResults: updatedKeyResults };
        });
        // Update the goal progress if needed
        if (goalId) get().updateGoalProgress(goalId);
      },
      
      updateGoalProgress: (goalId) => {
        try {
          console.log("Updating goal progress for goal:", goalId);
          
          set((state) => {
            // Check if goal exists
            const goalExists = state.goals.some(goal => goal.id === goalId);
            if (!goalExists) {
              console.warn("Goal not found with id:", goalId);
              return state; // Return unchanged state
            }
            
            // Get all key results for this goal
            const goalKeyResults = state.keyResults.filter(kr => kr.goalId === goalId);
            console.log("Key results for goal:", goalKeyResults);
            
            if (goalKeyResults.length === 0) {
              console.log("No key results found, setting progress to 0");
              // If there are no key results, set progress to 0
              return {
                goals: state.goals.map(goal => 
                  goal.id === goalId ? { ...goal, progress: 0 } : goal
                )
              };
            }
            
            // Calculate progress based on completed key results
            const completedCount = goalKeyResults.filter(kr => kr.status === 'completed').length;
            const totalCount = goalKeyResults.length;
            const progress = Math.round((completedCount / totalCount) * 100);
            console.log(`Progress: ${completedCount}/${totalCount} = ${progress}%`);
            
            return {
              goals: state.goals.map(goal => 
                goal.id === goalId ? { ...goal, progress } : goal
              )
            };
          });
        } catch (error) {
          console.error("Error in updateGoalProgress:", error);
        }
      },
      
      // TaskList actions
      addTaskList: (taskList) => {
        set((state) => ({ 
          taskLists: [...state.taskLists, { ...taskList, id: `list-${Date.now()}` }] 
        }));
      },
      
      updateTaskList: (id, updatedTaskList) => {
        set((state) => ({ 
          taskLists: state.taskLists.map(list => 
            list.id === id ? { ...list, ...updatedTaskList } : list
          ) 
        }));
      },
      
      deleteTaskList: (id) => {
        set((state) => ({ 
          taskLists: state.taskLists.filter(list => list.id !== id) 
        }));
      },
      
      // UI state actions
      setSelectedList: (listId) => {
        set({ selectedList: listId });
      },
      
      // Task Graph actions
      addTaskEdge: (edge) => {
        set((state) => ({ 
          taskEdges: [...state.taskEdges, edge] 
        }));
      },
      
      removeTaskEdge: (fromId, toId) => {
        set((state) => ({ 
          taskEdges: state.taskEdges.filter(edge => 
            edge.fromTaskId !== fromId || edge.toTaskId !== toId 
          ) 
        }));
      },
      
      findRelatedTasks: (taskId) => {
        const state = get();
        return state.tasks.filter(task => 
          task.relatedTaskIds?.includes(taskId)
        );
      },
      
      findSimilarTasks: (embedding, threshold = 0.5) => {
        const state = get();
        return state.tasks.filter(task => 
          task.embeddings && cosineSimilarity(task.embeddings, embedding) > threshold
        );
      },
      
      updateTaskEmbeddings: (taskId, embeddings) => {
        set((state) => ({ 
          tasks: state.tasks.map(task => 
            task.id === taskId ? { ...task, embeddings } : task
          ) 
        }));
      },
      
      generateTaskProposal: (input) => {
        // This is a placeholder implementation
        // In a real implementation, this would call an AI service
        const proposal: TaskProposal = {
          summary: input,
          steps: ['Step 1', 'Step 2', 'Step 3'],
          estimatedTime: '1 hour',
          risks: ['Potential challenge'],
          historyReferences: [],
          userAdaptation: 'Based on your preferences'
        };
        return proposal;
      },
    }),
    {
      name: 'task-graph-store',
      partialize: (state) => ({
        user: state.user,
        userProfile: state.userProfile,
        tasks: state.tasks,
        goals: state.goals,
        keyResults: state.keyResults,
        taskLists: state.taskLists,
        selectedList: state.selectedList,
        taskEdges: state.taskEdges,
      }),
    }
  )
);

/**
 * Helper function to calculate cosine similarity between two vectors
 */
function cosineSimilarity(vec1: number[], vec2: number[]): number {
  if (vec1.length !== vec2.length) {
    console.error('Vectors must be of the same length');
    return 0;
  }
  
  let dotProduct = 0;
  let mag1 = 0;
  let mag2 = 0;
  
  for (let i = 0; i < vec1.length; i++) {
    dotProduct += vec1[i] * vec2[i];
    mag1 += vec1[i] * vec1[i];
    mag2 += vec2[i] * vec2[i];
  }
  
  mag1 = Math.sqrt(mag1);
  mag2 = Math.sqrt(mag2);
  
  if (mag1 === 0 || mag2 === 0) return 0;
  
  return dotProduct / (mag1 * mag2);
}

// Helper function to generate unique IDs
function generateId(): string {
  return `task-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
} 